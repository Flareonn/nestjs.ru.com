(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{406:function(t,s,a){"use strict";a.r(s);var n=a(54),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"pipes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipes"}},[t._v("#")]),t._v(" Pipes")]),t._v(" "),a("p",[t._v("Pipe - это класс, аннотированный декоратором "),a("code",[t._v("@Injectable()")]),t._v(". Pipe должен реализовывать интерфейс "),a("code",[t._v("PipeTransform")]),t._v(".")]),t._v(" "),a("img",{attrs:{src:"/Pipe_1.png"}}),t._v(" "),a("p",[t._v("Pipes имеют два типичных случая использования:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("трансформация")]),t._v(": преобразование входных данных в нужную форму (например, из строки в целое число).")]),t._v(" "),a("li",[a("strong",[t._v("валидация")]),t._v(": оценить входные данные и, если они верны, просто передать их без изменений; в противном случае,\nесли данные неверны, выдать исключение.")])]),t._v(" "),a("p",[t._v("В обоих случаях pipes работают с "),a("code",[t._v("аргументами")]),t._v(", обрабатываемыми "),a("RouterLink",{attrs:{to:"/guide/controllers.html#параметры-маршрута"}},[t._v("обработчиком маршрута контроллера")]),t._v(".\nNest устанавливает pipe непосредственно перед вызовом метода, и этот pipe получает аргументы, предназначенные для\nметода, и работает с ними. Любая операция преобразования или проверки происходит в это время, после чего вызывается\nобработчик маршрута с любыми (потенциально) преобразованными аргументами.")],1),t._v(" "),a("p",[t._v('Nest поставляется с рядом встроенных pipes, которые вы можете использовать "из коробки". Вы также можете создавать свои\nсобственные pipes. В этой главе мы познакомимся со встроенными pipes и покажем, как привязать их к обработчикам\nмаршрутов. Затем мы рассмотрим несколько пользовательских pipes, чтобы показать, как можно создать их с нуля.')]),t._v(" "),a("blockquote",[a("p",[t._v("Pipes работают внутри зоны исключений. Это означает, что когда Pipe выбрасывает исключение, оно обрабатывается уровнем\nисключений (глобальный фильтр исключений и любые "),a("RouterLink",{attrs:{to:"/guide/exception-filters.html"}},[t._v("фильтры исключений")]),t._v(", которые применяются\nк текущему контексту). Учитывая вышесказанное, должно быть понятно, что когда исключение выбрасывается в Pipe,\nни один метод контроллера впоследствии не выполняется. Это дает вам наилучшую методику проверки данных, поступающих\nв приложение из внешних источников.")],1)]),t._v(" "),a("h2",{attrs:{id:"встроенные-pipes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#встроенные-pipes"}},[t._v("#")]),t._v(" Встроенные pipes")]),t._v(" "),a("p",[t._v("Nest поставляется с восемью pipes, доступными из коробки:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("ValidationPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseIntPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseFloatPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseBoolPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseArrayPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseUUIDPipe")])]),t._v(" "),a("li",[a("code",[t._v("ParseEnumPipe")])]),t._v(" "),a("li",[a("code",[t._v("DefaultValuePipe")])])]),t._v(" "),a("p",[t._v("Они экспортируются из пакета "),a("code",[t._v("@nestjs/common")]),t._v(".")]),t._v(" "),a("p",[t._v("Давайте рассмотрим использование "),a("code",[t._v("ParseIntPipe")]),t._v(". Это пример использования "),a("strong",[t._v("трансформации")]),t._v(", где pipe обеспечивает\nпреобразование параметра обработчика метода в целое число JavaScript (или выбрасывает исключение, если преобразование\nне удалось). Позже в этой главе мы покажем простую пользовательскую реализацию для "),a("code",[t._v("ParseIntPipe")]),t._v(". Приведенные ниже\nпримеры также применимы к другим встроенным pipes для трансформации данных ("),a("code",[t._v("ParseBoolPipe")]),t._v(", "),a("code",[t._v("ParseFloatPipe")]),t._v(",\n"),a("code",[t._v("ParseEnumPipe")]),t._v(", "),a("code",[t._v("ParseArrayPipe")]),t._v(" и "),a("code",[t._v("ParseUUIDPipe")]),t._v(", которые в этой главе мы будем называть семейством "),a("code",[t._v("Parse*")]),t._v(").")]),t._v(" "),a("h2",{attrs:{id:"привязка-pipe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#привязка-pipe"}},[t._v("#")]),t._v(" Привязка pipe")]),t._v(" "),a("p",[t._v("Чтобы использовать pipe, нам нужно привязать экземпляр класса pipe к соответствующему контексту.\nВ нашем примере "),a("code",[t._v("ParseIntPipe")]),t._v(" мы хотим связать pipe с определенным методом обработчика маршрута и убедиться,\nчто он будет запущен до вызова метода. Мы сделаем это с помощью следующей конструкции, которую мы будем\nназывать привязкой pipe на уровне параметров метода:")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("':id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Param")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ParseIntPipe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("catsService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Это гарантирует, что одно из следующих двух условий верно: либо параметр, который мы получаем в методе "),a("code",[t._v("findOne()")]),t._v(",\nявляется числом (как и ожидалось в нашем вызове "),a("code",[t._v("this.catsService.findOne()")]),t._v("), либо исключение будет выброшено\nдо вызова обработчика маршрута.")]),t._v(" "),a("p",[t._v("Например, предположим, что маршрут вызывается следующим образом:")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("GET localhost:3000/abc\n")])])]),a("p",[t._v("Nest выбросит исключение, подобное этому:")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"statusCode"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("400")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"message"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Validation failed (numeric string is expected)"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"error"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Bad Request"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Исключение не позволит выполнить тело метода "),a("code",[t._v("findOne()")]),t._v(".")]),t._v(" "),a("p",[t._v("В приведенном выше примере мы передаем класс ("),a("code",[t._v("ParseIntPipe")]),t._v("), а не экземпляр, оставляя ответственность\nза инстанцирование фреймворку и обеспечивая внедрение зависимостей. Как и в случае с pipes и guards,\nмы можем вместо этого передать экземпляр на месте. Передача экземпляра на месте полезна, если мы хотим настроить\nповедение встроенной pipe путем передачи опций:")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("':id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Param")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ParseIntPipe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" errorHttpStatusCode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" HttpStatus"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NOT_ACCEPTABLE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("catsService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Привязка других pipe преобразования (семейство "),a("strong",[t._v("Parse*")]),t._v(") работает аналогично. Все эти pipes работают\nв контексте проверки параметров маршрута, параметров строки запроса и значений тела запроса.")]),t._v(" "),a("p",[t._v("Например, с параметром строки запроса:")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Query")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ParseIntPipe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("catsService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Вот пример использования "),a("code",[t._v("ParseUUIDPipe")]),t._v(" для разбора строкового параметра и проверки, является ли он UUID.")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("':uuid'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Param")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'uuid'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ParseUUIDPipe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" uuid"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("catsService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("При использовании "),a("code",[t._v("ParseUUIDPipe()")]),t._v(" вы разбираете UUID версии 3, 4 или 5, если вам требуется только определенная\nверсия UUID, вы можете передать версию в опциях pipe.")])]),t._v(" "),a("p",[t._v("Выше мы рассмотрели примеры связывания различных встроенных pipe семейства "),a("code",[t._v("Parse*")]),t._v(". Привязка pipe валидации\nнемного отличается; мы обсудим это в следующем разделе.")]),t._v(" "),a("blockquote",[a("p",[t._v("Также смотрите "),a("a",{attrs:{href:"/guide/techniques/validation"}},[t._v("Техники валидации")]),t._v(" для подробных примеров pipe валидации.")])]),t._v(" "),a("h2",{attrs:{id:"пользовательские-pipes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#пользовательские-pipes"}},[t._v("#")]),t._v(" Пользовательские pipes")]),t._v(" "),a("p",[t._v("Как уже говорилось, вы можете создавать собственные пользовательские pipes. Хотя Nest предоставляет надежные\nвстроенные "),a("code",[t._v("ParseIntPipe")]),t._v(" и "),a("code",[t._v("ValidationPipe")]),t._v(", давайте построим простые пользовательские версии каждого из них с нуля,\nчтобы увидеть, как создаются пользовательские pipes.")]),t._v(" "),a("p",[t._v("Начнем с простого "),a("code",[t._v("ValidationPipe")]),t._v(". Изначально мы попросим его просто принимать входное значение и немедленно\nвозвращать то же значение.")]),t._v(" "),a("div",{staticClass:"filename"},[t._v("validation.pipe.ts")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" PipeTransform"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Injectable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ArgumentMetadata "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Injectable")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ValidationPipe")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PipeTransform")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("transform")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" metadata"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ArgumentMetadata"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("blockquote",[a("p",[a("code",[t._v("PipeTransform<T, R>")]),t._v(" - это общий интерфейс, который должен быть реализован любым pipe. Общий интерфейс использует "),a("code",[t._v("T")]),t._v("\nдля указания типа входного "),a("code",[t._v("value")]),t._v(" и "),a("code",[t._v("R")]),t._v(" для указания возвращаемого типа метода "),a("code",[t._v("transform()")]),t._v(".")])]),t._v(" "),a("p",[t._v("Каждый pipe должнен реализовать метод "),a("code",[t._v("transform()")]),t._v(" для выполнения контракта интерфейса "),a("code",[t._v("PipeTransform")]),t._v(". Этот метод\nимеет два параметра:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("value")])]),t._v(" "),a("li",[a("code",[t._v("metadata")])])]),t._v(" "),a("p",[t._v("Параметр "),a("code",[t._v("value")]),t._v(" - это текущий обрабатываемый аргумент метода (до его получения методом обработки маршрута),\nа "),a("code",[t._v("metadata")]),t._v(" - это метаданные текущего обрабатываемого аргумента метода. Объект метаданных имеет следующие свойства:")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArgumentMetadata")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'body'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'query'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'param'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'custom'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  metatype"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("unknown")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Эти свойства описывают текущий обрабатываемый аргумент.")]),t._v(" "),a("table",[a("tr",[a("td",[a("code",[t._v("type")])]),t._v(" "),a("td",[t._v("Указывает, является ли аргумент телом запроса\n      "),a("code",[t._v("@Body()")]),t._v(", get параметром\n      "),a("code",[t._v("@Query()")]),t._v(", параметром маршрута\n      "),a("code",[t._v("@Param()")]),t._v(", или пользовательским параметром (read more\n      "),a("a",{attrs:{href:"/guide/custom-decorators.html"}},[t._v("here")]),t._v(").\n    ")])]),t._v(" "),a("tr",[a("td",[a("code",[t._v("metatype")])]),t._v(" "),a("td",[t._v("\n      Указывает метатип аргумента, например\n      "),a("code",[t._v("String")]),t._v(". Примечание: значение будет равно\n      "),a("code",[t._v("undefined")]),t._v(" если вы либо опустите объявление типа в сигнатуре метода обработчика маршрута, либо используете ванильный JavaScript.\n    ")])]),t._v(" "),a("tr",[a("td",[a("code",[t._v("data")])]),t._v(" "),a("td",[t._v("Строка, передаваемая декоратору, например\n      "),a("code",[t._v("@Body('string')")]),t._v(". Значение будет равно\n      "),a("code",[t._v("undefined")]),t._v(" если оставить скобки декоратора пустыми.\n    ")])])]),t._v(" "),a("blockquote",[a("p",[t._v("Интерфейсы TypeScript исчезают при транспиляции. Таким образом, если тип параметра метода объявлен как интерфейс,\nа не как класс, значение "),a("code",[t._v("metatype")]),t._v(" будет "),a("code",[t._v("Object")]),t._v(".")])]),t._v(" "),a("h2",{attrs:{id:"валидация-на-основе-схемы"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#валидация-на-основе-схемы"}},[t._v("#")]),t._v(" Валидация на основе схемы")]),t._v(" "),a("p",[t._v("Давайте сделаем наш pipe валидации немного более полезным. Рассмотрим подробнее метод "),a("code",[t._v("create()")]),t._v(" контроллера\n"),a("code",[t._v("CatsController")]),t._v(", где мы хотим убедиться что объект post body является валидным, прежде\nчем пытаться запустить наш метод сервиса "),a("code",[t._v("CatsService")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Post")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Body")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" createCatDto"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" CreateCatDto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("catsService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("createCatDto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Давайте сосредоточимся на параметре body "),a("code",[t._v("createCatDto")]),t._v(". Его тип - "),a("code",[t._v("CreateCatDto")]),t._v(":")]),t._v(" "),a("div",{staticClass:"filename"},[t._v("create-cat.dto.ts")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CreateCatDto")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  breed"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Мы хотим убедиться, что любой входящий запрос к методу create содержит валидный body. Поэтому мы должны проверить\nтри параметра объекта "),a("code",[t._v("createCatDto")]),t._v(". Мы могли бы сделать это внутри метода обработчика маршрута, но такой подход не идеален,\nпоскольку он нарушит "),a("strong",[t._v("правило одной ответственности")]),t._v(" (single responsibility rule - SRP).")]),t._v(" "),a("p",[t._v("Другой подход может заключаться в создании класса "),a("strong",[t._v("validator")]),t._v(" и делегировании задачи туда. Это так же не идеально, т.к.\nнам придется помнить о вызове этого валидатора в начале каждого метода.")]),t._v(" "),a("p",[t._v("Как насчет создания middleware для валидации? Это может сработать, но, к сожалению,\nневозможно создать "),a("strong",[t._v("общий middleware")]),t._v(", который можно использовать во всех контекстах всего приложения.\nЭто происходит потому, что middleware не знает о "),a("strong",[t._v("контексте выполнения")]),t._v(", включая обработчик, который будет\nвызван, и любые его параметры.")]),t._v(" "),a("p",[t._v("Это, конечно, именно тот случай использования, для которого предназначены pipes. Итак, давайте продолжим и доработаем\nнаш pipe валидации.")])])}),[],!1,null,null,null);s.default=e.exports}}]);