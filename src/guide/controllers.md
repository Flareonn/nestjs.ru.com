# Контроллеры

Контроллеры отвечают за обработку входящих **запросов (Request)** и возврат **ответов (Response)** клиенту.

<img src="/Controllers_1.png" />

Назначение контроллера - принимать определенные запросы для приложения. 
Механизм **маршрутизации** контролирует, какой контроллер получает какие запросы. 
Часто каждый контроллер имеет более одного маршрута, и разные маршруты могут выполнять 
разные действия.

Чтобы создать базовый контроллер, мы используем классы и **декораторы**. 
Декораторы связывают классы с необходимыми метаданными и позволяют Nest "смапить" маршруты 
(привязать запросы к соответствующим контроллерам).

> Для быстрого создания CRUD-контроллера 
> со встроенной [валидацией](https://docs.nestjs.com/techniques/validation), 
> вы можете использовать [CRUD-генератор](https://docs.nestjs.com/recipes/crud-generator#crud-generator) 
> CLI: `nest g resource [name]`.

## Маршрутизация

В следующем примере мы будем использовать декоратор `@Controller()`, который **обязателен** 
для определения базового контроллера. Мы укажем необязательный префикс пути маршрута `cats`. 
Использование префикса пути в декораторе `@Controller()` позволяет нам легко группировать набор 
связанных маршрутов и минимизировать повторяющийся код. Например, мы можем сгруппировать 
набор маршрутов, управляющих взаимодействием с сущностью клиента, под маршрутом `/customers`. 
В этом случае мы можем указать префикс пути `customers` в декораторе `@Controller()`, чтобы 
не повторять эту часть пути для каждого маршрута в файле.

<div class="filename">cats.controller.ts</div>

```typescript
import { Controller, Get } from '@nestjs/common';
@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```

> Чтобы создать контроллер с помощью CLI, просто выполните команду `$ nest g controller cats`.


Декоратор `@Get()` перед методом `findAll()` указывает Nest на создание обработчика 
для определенного HTTP-запроса. Имя декоратора соответствует методу запроса HTTP 
(в данном случае GET) и пути маршрута. Что такое путь маршрута? Путь маршрута для 
обработчика определяется путем объединения (необязательного) префикса, объявленного 
для контроллера, и любого пути, указанного в декораторе метода. Поскольку мы объявили 
префикс для каждого маршрута ( `cats`) и не добавили никакой информации о пути в декораторе, Nest будет 
сопоставлять запросы `GET /cats` с этим обработчиком. Как уже упоминалось, путь включает в себя необязательный 
префикс пути контроллера **и** любую строку пути, объявленную в декораторе метода запроса. 
Например, префикс пути `customers` в сочетании с декоратором `@Get('profile')` вызовет данный метод 
для запроса `GET /customers/profile`.

В нашем примере выше, когда GET-запрос делается к этой конечной точке, Nest направляет запрос к нашему 
пользовательскому методу `findAll()`. Обратите внимание, что имя метода, которое мы выбрали здесь, 
совершенно произвольно. Очевидно, что мы должны объявить метод для привязки маршрута, но Nest не 
придает никакого значения выбранному имени метода.

Этот метод вернет код состояния 200 и соответствующий ответ, который в данном случае является просто строкой. 
Почему так происходит? Чтобы объяснить, мы сначала представим концепцию, что Nest использует два **различных** 
варианта для манипулирования ответами:

<table>
  <tr>
    <td>Стандартный (рекомендуется)</td>
    <td>
        Используя этот встроенный метод, когда обработчик запроса возвращает объект 
        JavaScript или массив, он будет <strong>автоматически</strong> сериализован в JSON. Однако если он возвращает 
        примитивный тип 
        JavaScript (например, <code>string</code>, <code>number</code>, <code>boolean</code>), Nest отправит только значение, 
        не пытаясь его сериализовать. 
        Это делает обработку ответа простой: просто верните значение, а Nest позаботится обо всем остальном.
        <br>
        <br>
        Кроме того, код состояния ответа по умолчанию всегда равен 200, за исключением POST-запросов, которые 
        используют 201. Мы можем легко изменить это поведение, добавив декоратор <code>@HttpCode(...)</code> на уровне обработчика 
        (см. <a href='controllers#status-code'>Коды состояния</a>).
    </td>
  </tr>
  <tr>
    <td>Специфический для библиотеки</td>
    <td>
        Мы можем использовать специфичный для библиотеки (например, Express) 
        <a href="https://expressjs.com/en/api.html#res" rel="nofollow" target="_blank">объект ответа</a>, который можно внедрить 
        с помощью декоратора <code>@Res()</code> в аргументы обработчика метода (например, <code>findAll(@Res() response) </code>). 
        При таком подходе у вас есть возможность использовать собственные методы обработки ответа, представленные этим объектом. 
        Например, в Express вы можете создавать ответы с помощью метода <code>response.status(200).send()</code>.
    </td>
  </tr>
</table>

<demo-component></demo-component>

## Объект запроса

Обработчикам часто требуется доступ к объекту **Request**. Nest предоставляет 
доступ к [объекту Request](https://expressjs.com/en/api.html#req) базовой платформы (по умолчанию Express). 
Мы можем получить доступ к объекту запроса, попросив Nest внедрить его, добавив декоратор `@Req()` перед обработчиком.

<div class="filename">cats.controller.ts</div>

```typescript
import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';
@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```

>  Для того, чтобы воспользоваться typescript типами фреймворка `express` (как в примере с параметром `request: Request` выше), установите пакет `@types/express`.

Объект request представляет HTTP-запрос и имеет свойства для доступа к параметрам запроса, HTTP-заголовкам и телу запроса 
(подробнее [здесь](https://expressjs.com/en/api.html#req)). В большинстве случаев нет необходимости получать эти 
свойства вручную. Вместо этого мы можем использовать специальные декораторы, такие как `@Body()` или `@Query()`, 
которые доступны из коробки. Ниже приведен список предоставляемых декораторов и объектов, специфичных для 
конкретной платформы, которые они представляют.

<table>
  <tbody>
    <tr>
      <td><code>@Request(), @Req()</code></td>
      <td><code>req</code></td></tr>
    <tr>
      <td><code>@Response(), @Res()</code><span class="table-code-asterisk">*</span></td>
      <td><code>res</code></td>
    </tr>
    <tr>
      <td><code>@Next()</code></td>
      <td><code>next</code></td>
    </tr>
    <tr>
      <td><code>@Session()</code></td>
      <td><code>req.session</code></td>
    </tr>
    <tr>
      <td><code>@Param(key?: string)</code></td>
      <td><code>req.params</code> / <code>req.params[key]</code></td>
    </tr>
    <tr>
      <td><code>@Body(key?: string)</code></td>
      <td><code>req.body</code> / <code>req.body[key]</code></td>
    </tr>
    <tr>
      <td><code>@Query(key?: string)</code></td>
      <td><code>req.query</code> / <code>req.query[key]</code></td>
    </tr>
    <tr>
      <td><code>@Headers(name?: string)</code></td>
      <td><code>req.headers</code> / <code>req.headers[name]</code></td>
    </tr>
    <tr>
      <td><code>@Ip()</code></td>
      <td><code>req.ip</code></td>
    </tr>
    <tr>
      <td><code>@HostParam()</code></td>
      <td><code>req.hosts</code></td>
    </tr>
  </tbody>
</table>

<sup>\* </sup>Для совместимости с типами, используемыми в базовых фреймворках HTTP (например, Express и Fastify), Nest предоставляет 
декораторы `@Res()` и `@Response()`. `@Res()` - это просто псевдоним для `@Response()`. Оба декоратора по сути дублируют
базовый интерфейс объекта `response` родной платформы. При их использовании следует также импортировать 
типы для базовой библиотеки (например, `@types/express`), чтобы воспользоваться всеми преимуществами. Обратите внимание, 
что когда вы вставляете `@Res()` или `@Response()` в обработчик метода, вы переводите Nest в режим, специфичный для 
библиотеки, и становитесь ответственным за управление ответом. При этом вы должны выдать какой-то ответ, сделав 
вызов объекта `response` (например, `res.json(...)` или `res.send(...)`), иначе HTTP-сервер зависнет.

> Чтобы узнать, как создавать собственные пользовательские декораторы, посетите [эту](/custom-decorators) главу.

## Ресурсы

Ранее мы определили маршрут для получения ресурса `cats` (маршрут **GET**). Обычно нам так же нужен
маршрут, который создает новые записи. Для этого создадим обработчик **POST**:

<div class="filename">cats.controller.ts</div>

```typescript
import { Controller, Get, Post } from '@nestjs/common';
@Controller('cats')
export class CatsController {
  @Post()
  create(): string {
    return 'This action adds a new cat';
  }
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```
Все очень просто. Nest предоставляет декораторы для всех стандартных методов HTTP: `@Get()`, `@Post()`, `@Put()`, 
`@Delete()`, `@Patch()`, `@Options()`, и `@Head()`. Кроме того, `@All()` определяет маршрут, который
обрабатывает их все.

## Шаблоны маршрутов

Поддерживаются также маршруты, основанные на шаблонах. Например, звездочка используется в качестве подстановочного 
знака и будет соответствовать любой комбинации символов.

```typescript
@Get('ab*cd')
findAll() {
  return 'This route uses a wildcard';
}
```
Маршрутный путь `'ab*cd'` будет соответствовать `abcd`, `ab_cd`, `abecd` и так далее. Символы `?`, `+`, `*` и `()` 
могут использоваться в маршрутном пути и являются подмножествами своих аналогов в регулярных выражениях. 
Дефис (`-`) и точка (`.`) интерпретируются буквально в строковых путях.

## Код статуса

Как уже упоминалось, код (**status code**) ответа по умолчанию всегда **200**, за исключением POST-запросов, которые 
отдают **201**. Мы можем легко изменить это поведение, добавив декоратор `@HttpCode(...)` на уровне обработчика.

```typescript
@Post()
@HttpCode(204)
create() {
  return 'This action adds a new cat';
}
```

> Импортируйте `HttpCode` из пакета `@nestjs/common`.

Часто **status code** не статичен, а зависит от различных факторов. В этом случае вы можете использовать 
специфичный для библиотеки **response** объект (с помощью `@Res()`), или в случае ошибки, выбросить исключение.

## Заголовки

Чтобы указать пользовательский заголовок ответа, вы можете использовать либо декоратор `@Header()`, либо специфический 
для библиотеки объект `response` (и вызвать `res.header()` напрямую).

```typescript
@Post()
@Header('Cache-Control', 'none')
create() {
  return 'This action adds a new cat';
}
```

> Импортируйте `Header` из пакета `@nestjs/common`.

## Редирект

Чтобы сделать редирект ответа на определенный URL, вы можете использовать либо декоратор `@Redirect()`, либо специфический 
для библиотеки объект `response` (и вызвать `res.redirect()` напрямую).

`@Redirect()` принимает два аргумента, `url` и `statusCode`, оба необязательны. Значение по умолчанию `statusCode` 
равно `302` (`Found`), если оно опущено.

```typescript
@Get()
@Redirect('https://nestjs.com', 301)
```

Иногда вам может понадобиться определить HTTP код ответа или URL редиректа динамически. Сделайте это
просто вернув подобный объект из метода обработчика маршрута:

```json
{
  "url": string,
  "statusCode": number
}
```

Возвращаемые значения будут переопределять любые аргументы, переданные декоратору `@Redirect()`. Например:

```typescript
@Get('docs')
@Redirect('https://docs.nestjs.com', 302)
getDocs(@Query('version') version) {
  if (version && version === '5') {
    return { url: 'https://docs.nestjs.com/v5/' }; // Нас отправит на https://docs.nestjs.com/v5/
  }
}
```

## Параметры маршрута

Маршруты со статическими путями не будут работать, когда вам нужно принять **динамические данные** как часть 
запроса (например, `GET /cats/1` для получения кошки с id `1`). Чтобы определить маршруты с параметрами, 
мы можем добавить **названия** параметров в путь маршрута для захвата динамического значения в данной 
позиции в URL запроса. Название параметра в примере декоратора `@Get()` ниже демонстрирует такое использование. 
К параметрам маршрута, объявленным таким образом, можно получить доступ с помощью декоратора `@Param()`, который 
следует добавить в аргументы метода.


```typescript
@Get(':id')
findOne(@Param() params): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}
```

`@Param()` используется для декорирования параметра метода (`params` в примере выше) и делает параметры **маршрута** 
доступными как свойства этого параметра внутри тела метода. Как видно из приведенного выше кода, 
мы можем получить доступ к параметру `id`, обратившись к `params.id`. Вы также можете передать в декоратор `@Param` определенное
название параметра, а затем ссылаться на параметр маршрута непосредственно по имени в теле метода.

> Импортируйте `Param` из пакета `@nestjs/common`.

```typescript
@Get(':id')
findOne(@Param('id') id: string): string {
  return `This action returns a #${id} cat`;
}
```

#### Маршрутизация по субдоменам

Декоратор `@Controller` может принимать опцию `host`, чтобы проверить, что HTTP-хост входящих запросов 
соответствовует некоторому определенному значению.

```typescript
@Controller({ host: 'admin.example.com' })
export class AdminController {
  @Get()
  index(): string {
    return 'Admin page';
  }
}
```

> Поскольку **Fastify** не поддерживает вложенные маршрутизаторы, при использовании поддоменной маршрутизации вместо 
> него следует использовать (по умолчанию) адаптер Express.

Подобно маршрутному пути, параметр `hosts` может использовать шаблоны для захвата динамического значения в данной 
позиции имени хоста. Шаблон параметра`host` в примере декоратора `@Controller()` ниже, демонстрирует такое 
использование. К параметрам хоста, объявленным таким образом, можно получить доступ с помощью декоратора 
`@HostParam()`, который должен быть добавлен в аргументы метода.

```typescript
@Controller({ host: ':account.example.com' })
export class AccountController {
  @Get()
  getInfo(@HostParam('account') account: string) {
    return account;
  }
}